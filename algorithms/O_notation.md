# Big O notation

> Это нотация для описания сложности алгоритма (используя подсчет кол-ва операций)

## O(1)
> Примеры алгоритмов, занимающих О(1)
```py
nums = [10,20,30,40] # 4 элемента
print(nums[0])
```
```py
dict_ = {'a':1, 'b':2, 'c':3} # 3 элемента
print(dict_['a'])
```

> Для данных алгоритмов (вывод значения по индексу или ключу), кол-во действий всегда будет 1. 
> Даже если элементов в списке или словаре будет 1000

## O(n)
> Если же мы захотим сделать обычный (линейный) поиск, то здесь кол-во операций зависит от кол-во элементов в итерируемом обьекте

```py
nums = [10,20,30,40] # 4 элемента
target = 50

def algo(nums, target):
    for num in nums: # пройдется 4 раза
        if num == target:
            return num

algo(nums, target)
```

> Тут нужно учитывать, что для вычисления сложности алгоритма мы должны проверять самый худший исход (который требует больше всего действий). В данном случае, это если такого элемента нет.

## O(n2)
> Чаще всего, это алгоритмы, которые итерируют обьект, и внутри каждой итерации снова его итерируют. Возьмем в пример не самый лучший алгоритм поиска дубликатов в списке

```py
nums = [1,2,3,4,5,5] # 6 элементов

def algo(nums):
    for i in range(len(nums)): # проходимся по индексам, чтобы достать первое число (num1)
        num1 = nums[i]
        for j in range(len(nums)): # снова проходимся по ним, чтобы достать второе число (num2)
            num2 = nums[j]
            if i == j:
                continue # переходим к следующему num2 числу, если мы взяли одно и то же число для num1 и num2
            if num1 == num2:
                return True
    return False

algo(nums)
```
> Cо списком в 6 элементов, наш алгоритм выполнит 30 операций
> В худшем случае (если у нас нет дубликатов), со списком в `6` элементов, наш алгоритм выполнит `36` операций

> Если у нас будет `100` элементов, то операций будет `10000`


## O(log n)
> Один из самый быстрых алгоритмов. Возьмем в пример алгоритм линейного поиска в **отсортированном** списке

```py
nums = [1,2,3,5,7,8,9] # 7 элементов
target = 10 # опять же худший вариант

def algo(nums, target):
    start = 0   # берем индекс начала списка
    end = len(nums) - 1   # берем индекс конца списка
    
    while start <= end: # итерируем, пока не найдем нужный элемент, или начало не будет равно или больше конца
        mid = len(nums) // 2  # находим индекс среднего элемента

        if nums[mid] == target:
            return mid # возвращаем индекс искомого элемента

        if target > nums[mid]: # если искомое число больше того, что по середине, то значит оно должно быть правее середины
            start = mid + 1 # за начало списка берем следуещее число от середины

        else: # если искомое число меньше того, что по середине, то значит оно левее от середины
            end = mid - 1 # за конец списка берем предыдущее число от середины
    
    # цикл прекратит работу если пройдемся по всему списку так и не найдя числа
    return False # элемента нет в списке

algo(nums, target)
```

> Мы взяли худший случай, когда у нас нет такого элемента (придется проходить по всему списку). Но даже при этом случае кол-во операций будет `3` (со списком в `7` элементов)
```py
# 1 операция
start = 0
end = 6
mid = 3 # число 5 (меньше, чем искомое 10), двигаемся вправо

# 2 операция
start = 4 # (следующее число от середины)
end = 6
mid = 5 # число 8 (меньше, чем 10), снова вправо

# 3 операция
start = 6
end = 6
mid = 6 # число 9 (мельше, чем 10), снова вправо, но мы дошли до конца
```

> На каждой из операций список, в котором мы ищем умельнается в `2 раза`
```py
# 1 операция
[1,2,3,5,7,8,9]

# 2 операция
[7,8,9]

# 3 операция
[9]
```

> Даже если возьмем список, состоящий из `1000` элементов и искомого числа там не будет, то кол-во операций будет всего `10`. В то время как у линейного вышло бы `1000` операций

> Если возьмем `1000000` (миллион) элементов и искомого числа там не будет, то кол-во операций будет всего `20`
